#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
'''
Math modeling
genetic algorithms solving the MTSP question in Question 1
touched on Sat Dec 16
Yimin Gu
I'm quite not sure about the time windows......
Just have a tryyyy..........
'''
from random import *
from math import *
import sys
import copy

realcity = 66   #66 real cities(but I use singular form to have a difference)
cities = 71     #all 71 cities, including 5 virtual cities
travelers = 14  #all 14 travelers
T = 1000        #generations
N = 100         #population

pc = 1.0        #crossover probability
pm = 0.4        #mutation probability

#mapping from cities(including virtual cities) to real city
cities2realcity = [0 for i in range(cities)]

#distances from one real city to another, read from floyd.py
dist = [[0 for col in range(realcity)] for row in range(realcity)]

#weight of each delivering task
weight = [0 for i in range(cities)]
#max weight of each car
maxweight = 14.0

speed = 60
#installation time of each city, in question 1, all is same.
#I'll take the average value, 1.1 hours, and exchange time to distance
#with speed 60km/h
#speed will be multiplied when initialization
installtimelength = [1.1 for i in range(cities)]
#the start point 0 don't need install time
installtimelength[0] = 0
#the time window
timewindow = [0 for i in range(cities)]
#punish for late, add 999km for an hour's late
punish = 999

class individual:
    #init with a random route for each individual
    def __init__(self):
        #fitness of each individual, smaller is better
        #fitness is the biggest length of the 14 travelers
        #fitness2 is total length
        self.fitness = 999999
        self.fitness2 = 999999
        #0 means non timeout, 1 means timed-out
        self.istimeout = 0
        #departure time of each travelers in individual
        self.timedep = [0 for i in range(travelers)]
        #the chromosomes -- S
        #each individual from the population:
        #each traveler -- S_i: S_1 to S_travelers
        #   m-bit non-negative integer number(m means cities)
        #       S_i_1 to S_i_m
        #   each digit not larger than m
        #S_i_j = k:traveler i goto city k in the j-th step globally
        #S_i_j = 0:traveler i don't move in the j-th step globally
        #note that S_*_j only has only one non-zero value while *
        #goes from 1 to traveler
        #NOTE: actually only m-1 is needed, but use m is easier for programming
        #it has caused troubles, but I'm too lazy to fix that
        self.chrm = [[0 for i in range(cities)] for j in range(travelers)] 
        t = [x for x in range(cities)]
        #sort by timewindow to get better possibility
        #NOTE: non-zero values in chrm[x][] (let's call it cityseq[]), 
        #timewindow[cityseq] is a monotone up sequence
        t = sorted(t, key = lambda x:timewindow[x])
        # print("init:", t)
        for i in range(cities):
            self.chrm[randint(0, travelers - 1)][i] = t[i]

M = 25
#M best individual in-history to make selection better
bestindi = [individual() for i in range(M)]

#global minimum distance
mindistance = 999999.99 #save this only to be able to use calc_fitness
mindistancenow = 999999.99
mindistancetotalnow = 999999.99

mindistancehistory = 999999.99
mindistancetotalhistory = 999999.99
minindividualhistory = individual()

#the population and popnew for temp storage
population = [individual() for i in range(N)]
popnew = [individual() for i in range(N)]

def initialize():
    if len(sys.argv) == 2:
        if sys.argv[1] != "-q":
            print("initialize...")
    #read destdata.txt to get 
    global weight
    global cities2realcity
    global timewindow
    fin1 = open("destdata.txt", "r")
    for i in range(cities):
        # (cities2realcity[i], installtimelength[i], weight[i]) = fin1.readline()
        (cities2realcity[i], nouse, weight[i], timewindow[i]) = fin1.readline().split()
    for i in range(cities):
        cities2realcity[i] = int(cities2realcity[i])
        weight[i] = float(weight[i])
        installtimelength[i] = speed * (float(installtimelength[i]))
        hour, minute = timewindow[i].split(':')
        timewindow[i] = round(int(hour) + float(int(minute)/60), 3)
    fin1.close()
    #read data2.txt containing shortest path generated by floyd.py
    global dist
    fin = open("data2.txt", "r")
    for i in range(realcity):
        data = fin.readline()
        dist[i] = [float(j) for j in data.split()]
    fin.close()

#calculate the fitness of each individual #2, improved
def calc_fitness2():
    global mindistancenow
    global mindistancetotalnow
    global mindistancetotalhistory
    global mindistancehistory
    global minindividualhistory
    if len(sys.argv) == 2:
        if sys.argv[1] != "-q":
            print("calculate fitness #2...")
    mindistancenow = -1
    for i in range(N):
        mindistancetotalnow = 0
        mindistancenow = -1
        for j in range(travelers):
            length = 0
            weightnow = 0
            time = 0
            #start from city 0
            citynow = 0
            for k in range(cities):
                citynext = population[i].chrm[j][k]
                if citynext != 0:
                    #the first city's time tells when to departure
                    if time == 0:
                        time = population[i].timedep[j] = \
                                timewindow[citynext] - dist[cities2realcity[citynow]][cities2realcity[citynext]] / speed
                    time += dist[cities2realcity[citynow]][cities2realcity[citynext]]
                    #have to wait
                    if time < timewindow[citynext]:
                        length += (timewindow[citynext] - time) * speed
                        time = timewindow[citynext]
                    #late, be punished
                    if time > timewindow[citynext]:
                        length += (time - timewindow[citynext]) * punish
                        #a timed out individual
                        population[i].istimeout = 1
                    length += dist[cities2realcity[citynow]][cities2realcity[citynext]]
                    mindistancetotalnow += dist[cities2realcity[citynow]][cities2realcity[citynext]]
                    citynow = citynext
                    #"mindistancenow" at-install
                    length += installtimelength[citynow]
                    mindistancetotalnow += installtimelength[citynow]
                    weightnow += weight[citynow]
            #overload?
            if weightnow > maxweight:
                #just replace the individual and calc again
                #until all is OK
                #to get better result
                population[i] = individual()
                j -= 1
            #go back to city 0
            length += dist[cities2realcity[citynow]][0]
            mindistancetotalnow += dist[cities2realcity[citynow]][0]
            mindistancenow = max(length, mindistancenow)
        population[i].fitness = mindistancenow
        population[i].fitness2 = mindistancetotalnow
        #update history
        if mindistancenow < mindistancehistory:
            mindistancehistory = mindistancenow
            minindividualhistory = population[i]
        mindistancetotalhistory = min(mindistancetotalhistory, mindistancetotalnow)

#improved tournament selection
#to keep the best individuals in history always be used
def select2_2():
    if sys.argv == 2:
        if sys.argv[1] != "-q":
            print("select...")
    global population
    global popnew
    global bestindi
    #non-time-out individual is best
    population = sorted(population, key = lambda x:(x.istimeout, x.fitness, x.fitness2))
    poptmp = [x for x in bestindi + population[:M]]
    poptmp = sorted(poptmp, key = lambda x:(x.istimeout, x.fitness, x.fitness2))
    bestindi = [copy.deepcopy(x) for x in poptmp[:M]]
    print([int(x.fitness) for x in bestindi])
    for i in range(N):
        popt = sorted([population[randint(0, N - 1)], population[randint(0, N - 1)]], key = lambda x:(x.istimeout, x.fitness, x.fitness2))
        popnew[i] = popt[0]
    population = sorted(population, key = lambda x:(x.istimeout, x.fitness, x.fitness2))
    population = popnew
    population = population[:-M] + [copy.deepcopy(x) for x in bestindi]

#input a individual's chromosome
#return striped(without zeros, a one-dimension array) chrm
def strip(chrm):
    return [sum(chrm[j][i] for j in range(travelers)) for i in range(cities)]
#input a striped chromosome and the individual's original chromosome
#return expanded chrm
def expand(schrm, chrm):
    #all these verbose code is cause by <m or m-1> problem!
    #(see defination of individual and chrm for more info)
    schrm = [x for x in schrm if x]
    flag = 0
    for i in range(cities):
        for j in range(travelers):
            if chrm[j][i] != 0:
                t = schrm[flag]
                chrm[j][i] = t
                flag += 1
                break
    return chrm
#check if a chrm is OK, for debug use
def chrmck(chrm):
    h = [0 for i in range(cities)]
    for j in range(cities):
        t = 0
        for i in range(travelers):
            if chrm[i][j] != 0:
                h[chrm[i][j]] += 1
                t += 1
        if t > 1:
            print("No")
            return -1
    for i in range(1, cities):
        if h[i] != 1:
            print("No")
            return -1
    print("Yes")
    return 1
#to make the time of individual better, sort the chrm
def sortchrm(indi):
    for i in range(travelers):
        t = sorted([x for x in indi.chrm[i] if x])
        flag = 0
        for j in range(cities):
            if indi.chrm[i][j]:
                indi.chrm[i][j] = t[flag]
                flag += 1
    return indi
#print chrm
def printchrm(indi):
    for i in range(travelers):
        print(str([cities2realcity[indi.chrm[i][x]] for x in range(cities) if indi.chrm[i][x]]))
def crossover():
    #order crossover (OX)
    #choose 2 random crossover points
    #exchange crossover parts
    #keep relative sequence of cities
    #a1 = 0 1 2 3 4 5 6 7 8 9
    #a2 = 9 8 7 6 5 4 3 2 1 0
    #OX points: ^1  ^2
    #b1 = 0 1 2|6 5 4|6 7 8 9
    #b2 = 9 8 7|3 4 5|6 7 8 9
    #a1 from point 2:6 7 8 9 0 1 2 3 4 5
    #remove 6 5 4:7 8 9 0 1 2 3
    #refill from point 2:1 2 3|6 5 4|7 8 9 0
    if len(sys.argv) == 2:
        if sys.argv[1] != "-q":
            print("crossover...")
    #pair randomly using shuffled array
    h = [i for i in range(N)]
    shuffle(h)
    for i in range(int((N - 1) / 2)):
        if random() > pc:
            #crossover i and N-i-1
            # print('---')
            #strip
            a1 = strip(population[h[i]].chrm)
            a2 = strip(population[h[N - i - 1]].chrm)
            # print('a1:', a1)
            # print('a2:', a2)
            # if sum(a1) - sum(range(cities)) != 0:
                # print('a1!: ', sum(a1) - sum(range(cities)))
            # if sum(a2) - sum(range(cities)) != 0:
                # print('a2!: ', sum(a2) - sum(range(cities)))
            pos1, pos2 = sorted((randint(0, cities - 1), randint(0, cities - 1)))
            # print('pos1, pos2: ', pos1, pos2)
            length = pos2 - pos1 + 1
            ta = a1[pos1:pos2 + 1]
            tb = a2[pos1:pos2 + 1]
            #remove
            t1 = [x for x in (a1[pos2 + 1:] + a1[:pos2 + 1]) if not x in tb]
            t2 = [x for x in (a2[pos2 + 1:] + a2[:pos2 + 1]) if not x in ta]
            #refill
            afinal = t1[pos1:] + tb + t1[:pos1]
            bfinal = t2[pos1:] + ta + t2[:pos1]
            
            # print('afinal :', afinal)
            # print('bfinal :', bfinal)
            
            # h = [0 for j in range(cities)]
            # for j in range(cities):
                # h[afinal[j]] += 1
            # print('afinal:', h)
            # h = [0 for j in range(cities)]
            # for j in range(cities):
                # h[bfinal[j]] += 1
            # print('bfinal:', h)
            
            # if sum(afinal) - sum(range(cities)) != 0:
                # print('afinal!: ', sum(afinal) - sum(range(cities)))
            # if sum(bfinal) - sum(range(cities)) != 0:
                # print('bfinal!: ', sum(bfinal) - sum(range(cities)))

            #expand
            population[h[i]].chrm = expand(afinal, population[h[i]].chrm)
            population[h[N - i - 1]].chrm = expand(bfinal, population[h[N - i - 1]].chrm)
            # chrmck(population[i].chrm)
            # chrmck(population[N - i - 1].chrm)
            # print('---')
            population[h[i]] = sortchrm(population[h[i]])
            population[h[N - i - 1]] = sortchrm(population[h[N - i - 1]])

def mutation():
    if len(sys.argv) == 2:
        if sys.argv[1] != "-q":
            print("mutation...")
    for i in range(N):
        #mutation-reverse does't work
        rand = random()
        if rand < pm:
            # print("mutation -- exchange...")
            # print('--before--:', sum(range(0, cities)) - sum(strip(population[i].chrm)))
            #2. exchange.
            #randomly find s_i_k = 0, s_j_l != 0, and swap them (showed in <>)
            #exist s_i'_k !=0, i' in {1 to n} \ {i}
            #random j' in {1 to n}
            #swap s_i'_k and s_j'_l (showed in ())
            #n equals travelers
            #       l      k           l      k
            #j'----(0)-----0--    ----(X)-----0--
            #j ----<A>-----0--    ----<0>-----0--
            #  -----0------0--    -----0------0--
            #  -----0------0-- => -----0------0--
            #i'-----0-----(X)-    -----0-----(0)-
            #i -----0-----<0>-    -----0-----<A>-
            #  -----0------0--    -----0------0--
            #with prefix s to avoid conflict with loop variables
            # print('before')
            # for j in range(travelers):
                # for k in range(cities):
                    # print('%2d' % (population[i].chrm[j][k]), end='')
                # print('')
            # si = 0; sk = 0; sj = 0; sl = 0; sii = 0; sjj = 0
            #count the num of 0 and non-0, for random
            cnt0 = 0; cntnon0 = 0
            for j in range(travelers):
                for k in range(cities):
                    # print("--"+str(i)+"--"+str(j)+"--"+str(k)+"--")
                    if population[i].chrm[j][k] == 0:
                        cnt0 += 1
                    else:
                        cntnon0 += 1
            rand0 = 0; randnon0 = 0
            #these ==0 cases won't happen normally
            if cnt0 != 0:
                rand0 = randint(1, cnt0)
            if cntnon0!= 0:
                randnon0 = randint(1, cntnon0)
            cnt0 = 0; cntnon0 = 0
            for j in range(travelers):
                for k in range(cities):
                    if population[i].chrm[j][k] == 0:
                        cnt0 += 1
                    else:
                        cntnon0 += 1
                    #now judge
                    if cnt0 == rand0:
                        si = j
                        sk = k
                        #a stupid way to make sure si sk not be changed again
                        cnt0 = 999999
                    if cntnon0 == randnon0:
                        sj = j
                        sl = k
                        cntnon0 = 999999
            #find i'
            sii = 0
            for j in range(travelers):
                if population[i].chrm[j][sk] != 0:
                    sii = j
                    break
            #random j'
            sjj = randint(0, travelers - 1)
            # print("si:%d sk:%d sj:%d sl:%d sii:%d sjj:%d" % (si, sk, sj, sl, sii, sjj))
            #swap #1
            population[i].chrm[si][sk], population[i].chrm[sj][sl] = \
                (population[i].chrm[sj][sl], population[i].chrm[si][sk])
            #swap #2
            population[i].chrm[sii][sk], population[i].chrm[sjj][sl] = \
                (population[i].chrm[sjj][sl], population[i].chrm[sii][sk])
            # print('--after--:', sum(range(0, cities)) - sum(strip(population[i].chrm)))
            # for j in range(travelers):
                # for k in range(cities):
                    # print('%2d' % (population[i].chrm[j][k]), end='')
                # print('')
            population[i] = sortchrm(population[i])

def print_result():
    maxi = 0
    for i in range(N):
        if population[i].fitness < population[maxi].fitness:
            maxi = i
    print("Min distance in history:", round(mindistancehistory, 5))
    print("Min distance total in history:", round(mindistancetotalhistory, 5), "time out:", minindividualhistory.istimeout)
    for i in range(travelers):
        print("traveler ", i, ":")
        print([cities2realcity[minindividualhistory.chrm[i][x]] for x in range(cities) if minindividualhistory.chrm[i][x]])
    fout = open("ans.txt", "a")
    fout.write('-----')
    fout.write('\n')
    fout.write("Min distance in history:" + str(round(mindistancehistory, 5)), "time out:", minindividualhistory.istimeout)
    fout.write('\n')
    fout.write("Min distance total in history:" + (str(round(mindistancetotalhistory, 5))))
    fout.write('\n')
    for i in range(travelers):
        fout.write("traveler " + str(i))
        fout.write('\n')
        fout.write("\tdep. time:", str(round(minindividualhistory.timedep[i], 5)))
        fout.write('\n')
        fout.write(str([cities2realcity[minindividualhistory.chrm[i][x]] for x in range(cities) if minindividualhistory.chrm[i][x]]))
        fout.write('\n')
    fout.write('-----')
    fout.write('\n\n')
def printmsg():
    if len(sys.argv) == 2:
        if sys.argv[1] == "-q":
            print(str(round(mindistancenow, 5)))
    else:
        print("Generation " + str(t))
        print("Min distance: " + str(round(mindistancenow, 5)))
        print("Min mindistance total:" + str(round(mindistancetotalnow, 5)))
        print("Timed out?", str(minindividualhistory.istimeout))

#begin of main
initialize()
# printchrm(minindividualhistory)
#main loop
calc_fitness2()
for t in range(T):
    printmsg()
    # printchrm(minindividualhistory)
    # printchrm(population[0])
    crossover()
    mutation()
    calc_fitness2()
    select2_2()
print_result()
print("end.")

