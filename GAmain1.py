#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
'''
genetic algorithms solving the MTSP question in Question 1
touched on Sat Dec 16
Yimin Gu
'''
from random import *
from math import *


cities = 66     #all 66 cities
travelers = 14  #all 14 travelers
T = 200     #generations
N = 500     #population

pc = 0.8    #crossover probability
pm = 0.1    #mutation probability

dist = [[0 for col in range(cities)] for row in range(cities)]


class individual:
    def __init__(self):
        #fitness of each individual
        self.fitness = 0
        #the chromosomes -- S
        #   a three-dimension array
        #each individual from the population:
        #each traveler -- S_i: S_1 to S_travelers
        #   m-bit non-negative integer number(m means cities)
        #       S_i_1 to S_i_m
        #   each digit not larger than m
        #S_i_j = k:traveler i goto city k in the j-th step globally
        #S_i_j = 0:traveler i don't move in the j-th step globally
        #note that S_*_j only has only one non-zero value while *
        #goes from 1 to traveler
        #
        #using this method is easier to program
        self.chrm = [[0 for k in range(cities)] for i in range(travelers)] 


#the population and popnew for temp storage
population = [individual() for i in range(N)]
popnew = [individual() for i in range(N)]

def initialize():
    #read data2.txt containing shortest path generated by floyd.py
    global dist
    fin = open("data2.txt", "r")
    for i in range(cities):
        data = fin.readline()
        dist[i] = [float(j) for j in data.split()]
    fin.close()
    #initialize population

#calculate the fitness of each individual
def calc_fitness():
    for i in range(N):
        length = 0
        citynow = 0
        for j in range(travelers):
            for k in range(cities):
                citynow = population[i].chrm[j][k]
                length += dist[citynow][k]
        population[i].fitness = length


#linear ranking selection
#probability of individual i: 
#p[i]=(a-b/(n+1))/n
#n is ranking
#a and b are constants 1<=a<=2, always 1.1, b=2a-2
def select():
    global population
    global popnew
    #sort
    population = sorted(population, key = lambda x: x.fitness)
    p = [0 for i in range(N)]
    selection = [0.0 for i in range(N)]
    pall = 0
    #get probability of each individual and total probability
    a = 1.1
    b = 2 * a - 2
    for i in range(N):
        n = i + 1
        p[i] = (a - b / (n + 1)) / (n)
        pall += p[i]
    #build up the selection, selection goes from smaller to larger
    for i in range(N):
        selection[i] = p[i] / pall
    for i in range(1, N):
        selection[i] += selection[i - 1]
    #choose randomly
    for i in range(N):
        #random real number from 0 to 1
        rand = random()
        idx = 0
        while rand > selection[idx]:
            idx += 1
        popnew[i] = population[idx]
    #copy
    for i in range(N):
        population[i] = popnew[i]

def crossover():
    #pair randomly
    hash = [i for i in range(N)]
    shuffle(hash)

def mutation():
    for i in range(N):
        #two kind of mutation, each probability is 0.5 * pm
        for j in range(travelers):
            rand = random()
            if rand < pm * 0.5:
                #1. reverse a slice of chrm between ranint1 and ranint2
                ranint1 = randint(0, cities)
                ranint2 = randint(0, cities)
                ranint1, ranint2 = sorted((ranint1, ranint2))
                population[i].chrm[j] = population[i].chrm[j][ranint1:ranint2][::-1]
        rand = random()
        if rand < pm * 0.5:
            #2. exchange.
            #randomly find s_i_k = 0, s_j_l != 0, and swap them (showed in <>)
            #exist s_i'_k !=0, i' in {1 to n} \ {i}
            #random j' in {1 to n}
            #swap s_i'_k and s_j'_l (showed in ())
            #n equals travelers
            #       l      k           l      k
            #j'----(0)-----0--    ----(X)-----0--
            #j ----<A>-----0--    ----<0>-----0--
            #  -----0------0--    -----0------0--
            #  -----0------0-- => -----0------0--
            #i'-----0-----(X)-    -----0-----(0)-
            #i -----0-----<0>-    -----0-----<A>-
            #  -----0------0--    -----0------0--
            #with prefix s to avoid conflict with loop variables
            si = 0; sk = 0; sj = 0; sl = 0; sii = 0; sjj = 0
            #count the num of 0 and non-0, for random
            cnt0 = 0; cntnon0 = 0
            for j in range(travelers):
                for k in range(cities):
                    print("--"+str(i)+"--"+str(j)+"--"+str(k)+"--")
                    if population[i].chrm[j][k] == 0:
                        cnt0 += 1
                    else:
                        cntnon0 += 1
                    print("--"+str(i)+"--"+str(j)+"--"+str(k)+"--")
            #these ==0 cases won't happen normally
            if cnt0 != 0:
                rand0 = randint(1, cnt0)
            if cntnon0!=0:
                randnon0 = randint(1, cntnon0)
            cnt0 = 0; cntnon0 = 0
            for j in range(travelers):
                for k in range(cities):
                    if population[i].chrm[j][k] == 0:
                        cnt0 += 1
                    else:
                        cntnon0 += 1
                    #now judge
                    if cnt0 == cnt0:
                        si = j; sk = k
                    if cnt0 == cntnon0:
                        sj = j; sl = k
            #swap #1
            population[i].chrm[si][sk], population[i].chrm[sj][sl] = \
                (population[i].chrm[si][sk], population[i].chrm[sj][sl])
            #find i'
            for j in range(travelers):
                if population[i].chrm[j][sk] != 0:
                    sii = j
                    break
            #random j'
            sjj = randint(1, travelers)
            #swap #2
            population[i].chrm[sii][sk], population[i].chrm[sjj][sl] = \
                (population[i].chrm[sii][sk], population[i].chrm[sjj][sl])


#begin of main
initialize()
#main loop
for t in range(T):
    calc_fitness()
    select()
    crossover()
    mutation()


